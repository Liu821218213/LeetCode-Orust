**[765. 情侣牵手](https://leetcode-cn.com/problems/couples-holding-hands/)**



### 解题思路

用一个字典记录下每个数字的下标，然后遍历数组

遍历数组只遍历偶数下标位置上的数字，然后看它的下一个位置的数字是否可以与其组成情侣，

如果是情侣，则跳过，否则交换位置。

交换位置是，有奇偶两种情况，一种当前位置为奇数，寻找上一个偶数。另一种当前位置为偶数，寻找下一个奇数。

根据字典的索引交换两个数字的位置，然后实时更新字典的下标索引。

这样子交换一定能得到最终结果，因为本题满足**贪心选择性质**，只要保证局部最优，就能得到整体最优。

即，在本题中，每次（每轮循环）都至少使一对情侣坐到一起，那么最终所有情侣坐到一起所移动的次数一定是最少的。

举个例子:

row = [0,2,3,4,5,6,7,8,9,1]

按照准则：每次（每轮循环）都至少使一对情侣坐到一起

如果采用如下移动方式：（从后往前）

```
row = [0, 2, 3, 4, 5, 6, 7, 8, 9, 1]
[0, 2, 3, 4, 5, 6, 7, 1, 9, 8]
[0, 2, 3, 4, 5, 1, 7, 6, 9, 8]
[0, 2, 3, 1, 5, 4, 7, 6, 9, 8]
[0, 1, 3, 2, 5, 4, 7, 6, 9, 8]
```

每次都将1向前移动一点，每次都有至少使一对情侣坐到一起，则一共移动了四次。

然后再采用如下方式：（从前往后，即本题解代码的移动过程）
```
row = [0, 2, 3, 4, 5, 6, 7, 8, 9, 1]
[0, 1, 3, 4, 5, 6, 7, 8, 9, 2]
[0, 1, 3, 2, 5, 6, 7, 8, 9, 4]
[0, 1, 3, 2, 5, 4, 7, 8, 9, 6]
[0, 1, 3, 2, 5, 4, 7, 6, 9, 8]
```
可以看出，也移动了四次。

所以，不管是从后往前还是从前往后，只要满足贪心准则：**每次移动都使至少一对情侣坐到一起。**

那么最终次数就是最少的。


Time:O(n)，只需遍历一遍数组

Space:O(n)，一个字典的空间，当然用数组替代也行

n为row数组长度

### 代码

```python3
# 贪心准则：每次移动都使至少一对情侣坐到一起。
class Solution:
    def minSwapsCouples(self, row: List[int]) -> int:
        dic = {num: idx for idx, num in enumerate(row)}      # 字典记录下标
        cnt = 0
        for i in range(0, len(row), 2):                      # 步长为2
            temp = row[i] - 1 if row[i] % 2 else row[i] + 1  # 看当前位置是奇数还是偶数
            if row[i + 1] != temp:
                idx = dic[temp]
                row[i + 1], row[idx] = row[idx], row[i + 1]  # 交换位置，贪心
                dic[row[idx]], dic[temp] = idx, i + 1        # 更新字典
                cnt += 1
        return cnt
```
