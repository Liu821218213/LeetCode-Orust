91的最后一天，还是过的很快的，三个过去了。

每天做题已经习惯了，每天打开电脑第一步点开91题目。

收获了不少，能够耐心的总结题目和思路是自己单独刷题做不到的。

西法大大的题型安排，循序渐进也很全面，几乎是包含所有的算法基础知识，而且全都有讲义配套。

说到讲义，每个讲义都很用心。

每个官方题解也都在看，有的时候对自己做的不满意，看其他同学的方法也能学到很多。

给所有辛苦的老师们点赞，感谢。也感谢一起刷题的朋友们，一起加油💪。

最后附上我的
**[91算法刷题全记录](https://github.com/Liu821218213/LeetCode-Orust/tree/master/LeetCode%2B%2B)**

---------------------------
---------------------------


**[881. 救生艇](https://leetcode-cn.com/problems/boats-to-save-people/)**

以前做过的一题


### 解题思路
一开始会想到两个指针都从最大的值开始走，因为这样的贪心准则一定能保证最优

分析：

如果已经选了一个最大的和第二大的，如果这两个能配对，
那么第二大的与任何一个都能配对，并不用担心它上不了船，所以这时候选择最小的和最大的配对

一方面，这样的两边双指针很快
另一方面，每次最大与最小的配对，对于船只来说，某种程度上是充分利用了空间

试想，如果每次都是两个胖子在一个船，虽然最后也能找到最优解
但是两个瘦子最后也在一个船了啊，这样就是浪费空间了

**贪心准则：每次选择最大的与最小的配对**

Time:O(nlogn)，n为数组长度，排序的时间，除此之外只需要遍历数组一遍，直接贪心即可

Space:O(1)，不算重量数组，排序为原地的情况下

### 代码

```python3
class Solution:
    def numRescueBoats(self, people: List[int], limit: int) -> int:
        people.sort()
        i, j = 0, len(people) - 1
        num = 0
        while i <= j:
            if people[i] + people[j] > limit:
                j -= 1
            else:
                j -= 1
                i += 1
            num += 1
        return num
```
