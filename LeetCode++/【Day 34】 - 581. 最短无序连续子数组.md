**[581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)**


### 解题思路
这题也是踩了几个坑

题目给的测试数据：`[2,6,4,8,10,9,15]`
刚开始最简单的想法就是左右两个指针，
左边找第一个不满足递增的，右边找第一个不满足递减的，以为`return j - i + 1`就行了。

但是：
**问题1**：如果左右两指针相遇，就是已经是排序好的数组了，那么要返回的是0（这个最容易发现的坑还是考虑到了）。

**问题2**：遇到了`[1,3,2,2,2]`，我天真的以为改改`>、=>、<=、<`就行了，直到又wrong了一次：`[2,3,3,2,4]`，
眉头一皱，发现问题并不是这么简单，这个时候才真正弄懂了问题。

自己也搞了一个测试数据：`[10,9,8,7,6,3,4,5,11]`

#### 代码解释
**首先**，还是两个指针i和j，左边找第一个不满足递增的，右边找第一个不满足递减的（前两个while循环）
找到之后，在这两个指针之间再继续走，找到下标在`[i,j]`区间的最大值和最小值（第三个循环for）
PS：在`[2,6,4,8,10,9,15]`中，i停在了1，j停在了5，在`[10,9,8,7,6,3,4,5,11]`中，i停在了0，j停在了5

**至此**，时间复杂度为O(n)，因为刚遍历完一遍数组，此时`[i,j]`区间的最大和最小值分别为left和right。

**然后**，继续从两头找，但是这次找的条件换了：
左边找第一个大于left的，右边找第一个小于right的，找到之后，就是我们需要的结果，即需要重新排序的最小子序列的两头。
PS：在这次的循环中，在`[2,6,4,8,10,9,15]`中，i停在了1，j停在了5，在`[10,9,8,7,6,3,4,5,11]`中，i停在了0，j停在了7

这里的时间复杂度也不超过O(n)

#### 时空分析
时间复杂度：O(n)，n为数组长度，并列的循环，时间复杂度并不增加
空降复杂度：O(1)，只需常量空间

### 代码

```python3
class Solution:
    def findUnsortedSubarray(self, nums: List[int]) -> int:
        i, j = 0, len(nums) - 1
        while i < j and nums[i] <= nums[i + 1]: i += 1
        while i < j and nums[j] >= nums[j - 1]: j -= 1

        left, right = nums[i], nums[j]
        for k in range(i, j + 1):
            right = max(right, nums[k])
            left = min(left, nums[k])

        i, j = 0, len(nums) - 1
        while i < j and nums[i] <= left: i += 1
        while i < j and nums[j] >= right: j -= 1

        return j - i + 1 if i != j else 0

```
